{"pages":[{"title":"关于我","permalink":"https://www.miaomiaomiao.info/about/index.html","text":"QQ: 1178574705 邮箱: zyzeng1234@gmail.com"}],"posts":[{"title":"knn算法","permalink":"https://www.miaomiaomiao.info/knn/","text":"Knn算法算法概述对于一个未知分类的点，在n维空间中与其他所有点计算其欧式距离，取距离最近的k个点（k值自取），在这k个点中选取最多标签的那个分类作为这个未知分类的点的标签。 需要注意的点 怎么度量邻近度 我们首先想到的肯定是点和点之间距离。但除了距离，其实我们也可以考虑两个点之间的相似度，越相似，就代表两个点距离越近。同理，我们也可以考虑相异度，越相异，就代表两个点距离越远。其实距离的度量就是相异性度量的其中一种。一般采取计算欧式距离。 k值怎么取 k值的选取关乎整个分类器的性能。如果k值取得过小，容易受噪点的影响而导致分类错误。而k值取得过大，又容易分类不清，混淆了其他类别的点。 数据的预处理 拿到数据，我们不能直接就开始套用算法，而是需要先规范数据。例如我们想通过一个人的年龄和工资来进行分类，很明显工资的数值远大于年龄，如果我们不对它进行一个统一的规范，必然工资这个特征会左右我们的分类，而让年龄这个特征无效化，这不是我们想看到的。 存在的问题因为要扫描全部训练样本并计算距离，所以开销大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889## python代码实现#!/usr/bin/python# coding=utf-8########################################## kNN: k Nearest Neighbors# 输入: newInput: (1xN)的待分类向量# dataSet: (NxM)的训练数据集# labels: 训练数据集的类别标签向量# k: 近邻数# 输出: 可能性最大的分类标签#########################################from numpy import *import operator# 创建一个数据集，包含2个类别共4个样本def createDataSet(): # 生成一个矩阵，每行表示一个样本 group = array([[1.0, 0.9], [1.0, 1.0], [0.1, 0.2], [0.0, 0.1]]) # 4个样本分别所属的类别 labels = ['A', 'A', 'B', 'B'] return group, labels# KNN分类算法函数定义def kNNClassify(newInput, dataSet, labels, k): numSamples = dataSet.shape[0] # shape[0]表示行数 # # step 1: 计算距离[ # 假如： # Newinput：[1,0,2] # Dataset: # [1,0,1] # [2,1,3] # [1,0,2] # 计算过程即为： # 1、求差 # [1,0,1] [1,0,2] # [2,1,3] -- [1,0,2] # [1,0,2] [1,0,2] # = # [0,0,-1] # [1,1,1] # [0,0,-1] # 2、对差值平方 # [0,0,1] # [1,1,1] # [0,0,1] # 3、将平方后的差值累加 # [1] # [3] # [1] # 4、将上一步骤的值求开方，即得距离 # [1] # [1.73] # [1] # # ] # tile(A, reps): 构造一个矩阵，通过A重复reps次得到 # the following copy numSamples rows for dataSet diff = tile(newInput, (numSamples, 1)) - dataSet # 按元素求差值 squaredDiff = diff ** 2 # 将差值平方 squaredDist = sum(squaredDiff, axis = 1) # 按行累加 distance = squaredDist ** 0.5 # 将差值平方和求开方，即得距离 # # step 2: 对距离排序 # argsort() 返回排序后的索引值 sortedDistIndices = argsort(distance) classCount = &#123;&#125; # define a dictionary (can be append element) for i in xrange(k): # # step 3: 选择k个最近邻 voteLabel = labels[sortedDistIndices[i]] # # step 4: 计算k个最近邻中各类别出现的次数 # when the key voteLabel is not in dictionary classCount, get() # will return 0 classCount[voteLabel] = classCount.get(voteLabel, 0) + 1 # # step 5: 返回出现次数最多的类别标签 maxCount = 0 for key, value in classCount.items(): if value &gt; maxCount: maxCount = value maxIndex = key return maxIndex 测试文件： 1234567891011121314151617#!/usr/bin/python# coding=utf-8import KNNfrom numpy import *# 生成数据集和类别标签dataSet, labels = KNN.createDataSet()# 定义一个未知类别的数据testX = array([1.2, 1.0])k = 3# 调用分类函数对未知数据分类outputLabel = KNN.kNNClassify(testX, dataSet, labels, 3)print \"Your input is:\", testX, \"and classified to class: \", outputLabeltestX = array([0.1, 0.3])outputLabel = KNN.kNNClassify(testX, dataSet, labels, 3)print \"Your input is:\", testX, \"and classified to class: \", outputLabel"},{"title":"web图书馆管理系统前端","permalink":"https://www.miaomiaomiao.info/springboot图书馆前/","text":"本次图书馆管理系统开发过程：分析表关系表关系比较简单，图书与图书分类为多对一关系，借阅书目与用户为多对一关系，借阅书目与书籍为多对一关系（实际上并没有用到这层关系，因为并没有做前台的借书功能(′Д`)）sql语句贴出一个借阅书目的，数据库用的是MySQL： create table orderbook( id int(11) not null auto_increment, name varchar(255) default null, uid int(11) default null, bid int(11) default null, borrowdate timestamp default CURRENT_TIMESTAMP, constraint pk_orderbook_user foreign key (uid) references user (id), constraint pk_orderbook_book foreign key (bid) references book (id), primary key(id) )engine=innodb default charset=utf8; 建立之后如图： 配置springboot配置文件springboot的配置文件主要用来写入数据库驱动用户名密码和其他一些配置 #database spring.datasource.url=jdbc:mysql://127.0.0.1:3306/library_manage?characterEncoding=UTF-8 spring.datasource.username=root spring.datasource.password=admin spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.hibernate.ddl-auto = none #thymeleaf spring.thymeleaf.mode=LEGACYHTML5 spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.content-type=text/html spring.thymeleaf.cache=false #context,页面地址访问就以localhost:8080/开头， #server.context-path=/library,则以localhost:8080/library开头 server.context-path=/ #设置上传文件大小，默认只有1 m spring.http.multipart.maxFileSize=100Mb spring.http.multipart.maxRequestSize=100Mb #jpa对实体类的默认字段会把驼峰命名的属性，转换为字段名的时候自动加上下划线。 这个配置的作用就是去掉下划线 #比如属性名称是 createDate, jpa 默认转换为字段名 create_Date。 有了这个配置之后，就会转换为同名字段 createDate spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl #显示 hibernate运行的 sql 语句 spring.jpa.show-sql=true 前端部分前端部分采用的是thymeleaf模板引擎和vue.js渲染页面数据和绑定数据（vue这里仅仅是用到了这两个功能，没有用到脚手架），前端样式采用的bootstrap。 thymeleaf将网页模块化如图，页面目录如下： admin目录下的页面分别： listCategory.html: 显示所有书籍分类的列表 editCategory.html: 编辑书籍名字的页面 listBook.html: 显示分类下书籍列表的页面 listOrderBook.html: 显示每个用户下借阅书籍列表的页面 listOrderAll.html: 显示所有借阅的书籍的页面 listUser.html：显示所有用户列表的页面 login.html: 登录页面 include/admin目录下的页面分别为： adminHeader.html: 将所有前端页面中用到的一些函数统一写到了这个页面里 adminNavigator.html 基本每个页面都有的导航栏放在这个页面里 adminPage.html 分页跳转方法写在这个页面里 adminFooter.html 页脚 这样可以使得将页面中通用的部分单独拿出来，通过thymeleaf进行镶嵌 利用thymeleaf将include/admin中的页面嵌入到admin里的页面中，如下： 123456789101112&lt;!DOCTYPE html&gt; &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head th:include=\"include/admin/adminHeader::html('分类管理')\" &gt;&lt;/head&gt; //在head中插入adminHeader.html &lt;body&gt; &lt;div th:replace=\"include/admin/adminNavigator::html\" &gt;&lt;/div&gt; //在body的一开头插入导航栏adminNavigator.html &lt;div id=\"workingplace\"&gt; 此处省略一万行 &lt;div th:replace=\"include/admin/adminPage::html\" &gt;&lt;/div&gt; //插入分页 &lt;/div&gt; &lt;div th:replace=\"include/admin/adminFooter::html\" &gt;&lt;/div&gt; &lt;/body&gt; adminHeader内包含所需要的外部js文件已经css文件，代码如下： 1234567891011121314151617181920212223242526&lt;template th:fragment=\"html(title)\" &gt; &lt;script src=\"js/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt; &lt;link href=\"css/bootstrap/3.3.6/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"js/bootstrap/3.3.6/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/vue/2.5.16/vue.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/axios/0.17.1/axios.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/moment/2.22.2/moment.js\"&gt;&lt;/script&gt; &lt;!-- vue.js 格式化日期用的 --&gt; &lt;link href=\"css/back/style.css\" rel=\"stylesheet\"&gt; &lt;script&gt; //判断是否为空 function checkEmpty(value,text)&#123; if(null==value || value.length==0)&#123; alert(text+ \"不能为空\"); return false; &#125; return true; &#125; ... //此处省略 ... &lt;/script&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title th:text=\"$&#123;title&#125;\" &gt;&lt;/title&gt;&lt;/template&gt; template标签配合th:include可以实现加载template模板中的内容，template标签加载后自动忽略。而th:replace则是配合div标签自动将当前的div替换为th:replace的div标签 adminNavigator.html的代码 1234567891011121314&lt;div class=\"navitagorDiv\" th:fragment=\"html\"&gt; &lt;nav class=\"navbar navbar-default navbar-fixed-top navbar-inverse\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;img style=\"margin-left:10px;margin-right:0px\" class=\"pull-left navbar-brand\" src=\"img/site/library.jpg\" height=\"45px\"&gt; &lt;a class=\"navbar-brand\" href=\"/admin_login\"&gt;图书馆管理后台&lt;/a&gt; &lt;a class=\"navbar-brand\" href=\"admin_category_list\"&gt;分类管理&lt;/a&gt; &lt;a class=\"navbar-brand\" href=\"admin_user_list\"&gt;用户管理&lt;/a&gt; &lt;a class=\"navbar-brand\" href=\"/admin_orderall_list\"&gt;借阅管理&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/div&gt; 分类列表中的代码片段： 123&lt;head th:include=\"include/admin/adminHeader::html('分类管理')\" &gt;&lt;/head&gt;&lt;body&gt;&lt;div th:replace=\"include/admin/adminNavigator::html\" &gt;&lt;/div&gt; TIM截图20190326095920.png 如上，通过镶嵌，这样每个页面就有一个导航栏 vue进行页面数据渲染以listCategory.hmtl书籍分类列表页面为例： TIM截图20190326102748.png 上图部分html代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id=\"workingArea\" &gt; &lt;div class=\"listDataTableDiv\"&gt; &lt;table class=\"table table-striped table-bordered table-hover table-condensed\"&gt; &lt;thead&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;分类名称&lt;/th&gt; &lt;th&gt;书籍管理&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"bean in beans \"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;a :href=\"'admin_book_list?cid=' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-shopping-cart\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;td&gt; &lt;a :href=\"'admin_category_edit?id=' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-edit\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=\"#nowhere\" @click=\"deleteBean(bean.id)\"&gt;&lt;span class=\" glyphicon glyphicon-trash\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class=\"panel panel-warning addDiv\"&gt; &lt;div class=\"panel-heading\"&gt;新增分类&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;table class=\"addTable\"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input @keyup.enter=\"add\" v-model.trim=\"bean.name\" type=\"text\" class=\"form-control\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"submitTR\"&gt; &lt;td colspan=\"2\" align=\"center\"&gt; &lt;a href=\"#nowhere\" @click=\"add\" class=\"btn btn-success\"&gt;提交&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div th:replace=\"include/admin/adminPage::html\" &gt;&lt;/div&gt;&lt;/div&gt; 由一个存放书籍列表的表格table，和一个显示添加书籍的表格组成。 vue脚本部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script&gt; $(function()&#123; var data4Vue = &#123; uri:'categories', pagination:&#123;&#125;, beans: [], bean:&#123;id:0,name:\"\"&#125;, file:null, keyword:'' &#125;; //ViewModel var vue = new Vue(&#123; el: '#workingArea', data: data4Vue, mounted:function()&#123; //mounted 表示这个 Vue 对象加载成功了 this.list(0); &#125;, methods: &#123; list:function(start)&#123; var url = this.uri+ \"?start=\"+start; axios.get(url).then(function(response) &#123; vue.pagination = response.data; vue.beans = response.data.content; &#125;); &#125;, listSearch:function () &#123; var url = \"search?keyword=\"+vue.keyword; axios.post(url).then(function (response) &#123; vue.beans = response.data; &#125;) &#125;, jump: function(page)&#123; jump(page,vue); //定义在adminHeader.html 中 &#125;, jumpByNumber: function(start)&#123; jumpByNumber(start,vue); &#125;, add: function () &#123; var url = this.uri; axios.post(url,vue.bean).then(function () &#123; vue.list(0); vue.bean = &#123;id:0,name:'',hp:'0'&#125;; &#125;) &#125;, deleteBean:function (id) &#123; if(!checkDeleteLink()) return; var url = this.uri+\"/\"+id; axios.delete(url).then(function (response) &#123; if (0!=response.data.length) //rest规范删除数据要求要会返回空字符串（控制器中delete返回null），所以进行判断 alert(response.data); else vue.list(0); //是空字符串则调第一页 &#125;) &#125; &#125; &#125;); &#125;);&lt;/script&gt; 页面渲染流程如下： 其中： $()是jquery中的用法，表示页面html文档加载完毕后自动执行里面的脚本。 1$(function () &#123;。。。&#125;) var data4Vue是vue中定义的数据变量，也可以直接写在vue对象里 1234567var data4Vue = &#123; uri:'categories', pagination:&#123;&#125;, beans: [], bean:&#123;id:0,name:\"\"&#125;, keyword:'' &#125;; vue里的el:#workingArea表示该vue对象是对id为workingArea的html标签区域进行数据渲染 mounted表示对象加载完毕时自动执行mounted里面的函数 methods在里面编写页面所需要的函数 methods里的list函数中 1234567list:function(start)&#123; var url = this.uri+ \"?start=\"+start; axios.get(url).then(function(response) &#123; vue.pagination = response.data; vue.beans = response.data.content; &#125;); &#125;, url为请求的地址，？后面为请求参数，服务器后端程序能通过注解自动识别？后的参数。 axios请求函数可以是get，post，delete等依情况定，请求成功后才会执行then里面的函数。then里面函数将返回的数据赋值给vue的数据变量中，vue通过在html标签中绑定的数据变量从而将数据渲染到页面中(请求的具体流程图在之后的后端部分给出)，如下，beans变量 1234567891011121314151617&lt;tbody&gt; &lt;tr v-for=\"bean in beans \"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;a :href=\"'admin_book_list?cid=' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-shopping-cart\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;td&gt; &lt;a :href=\"'admin_category_edit?id=' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-edit\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=\"#nowhere\" @click=\"deleteBean(bean.id)\"&gt;&lt;span class=\" glyphicon glyphicon-trash\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; 输入框等表单用v-model双向绑定，即输入的内容会绑定到v-model后的数据变量里，同时数据变量值的改变也会改变表单中的值。 页面样式样式主要采用bootstrap，在adminHeader.html引入 adminNavigator.html中导航栏样式 123456789&lt;nav class=\"navbar navbar-default navbar-fixed-top navbar-inverse\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;img style=\"margin-left:10px;margin-right:0px\" class=\"pull-left navbar-brand\" src=\"img/site/library.jpg\" height=\"45px\"&gt; &lt;a class=\"navbar-brand\" href=\"/admin_login\"&gt;图书馆管理后台&lt;/a&gt; &lt;a class=\"navbar-brand\" href=\"admin_category_list\"&gt;分类管理&lt;/a&gt; &lt;a class=\"navbar-brand\" href=\"admin_user_list\"&gt;用户管理&lt;/a&gt; &lt;a class=\"navbar-brand\" href=\"/admin_orderall_list\"&gt;借阅管理&lt;/a&gt; &lt;/div&gt; &lt;/nav&gt; nav标签中的属性navbar navbar-default nvarbar-fixed-top navbar-inverse分别就是bootstrap样式中的导航栏，导航栏默认样式，固定不随页面滑动，颜色反转（本来是白色的） 页面中展示数据的表格所用的样式： list.png 12345&lt;table class=\"table table-striped table-bordered table-hover table-condensed\"&gt;&lt;tr class=\"success\"&gt; table：普通表格，table-striped：斑马线（颜色交替），table-border：列与列之间的分割线，table-hover：鼠标经过有效果，table-condensed：响应式效果，根据页面大小变换。行标签中有集中颜色可选，其中success为绿色 添加书籍分类的面板： 面板.png 12345&lt;div class=\"panel panel-warning addDiv\"&gt; &lt;div class=\"panel-heading\"&gt;新增分类&lt;/div&gt; &lt;div class=\"panel-body\"&gt; ..... ... panel：一个面板, panel-warning：颜色警告色（黄色）panel-heading：面板标题，body为面板内容面板里的内容为一个2x2的table构成 登录页面 TIM截图20190326202043.png 登录页面采用bootstrap中的栅格化布局（网上物色的登录界面，在css中改了背景）。基本思想是bootstrap将页面分成了12份利用class属性col-lg-xx来配置个标签所占位置 ，如图： TIM截图20190326204248.png 所以标题输入框以及按钮class中都设置超过6的数值就会一行的一行的排列。input中的required属性表示不能为空，autofocus表示页面加载后自动获得焦点 1234567891011121314151617181920212223242526272829&lt;div id=\"form\"&gt;&lt;form&gt; &lt;div class=\"mycenter\"&gt; &lt;div class=\"mysign\"&gt; &lt;div class=\"col-lg-12 text-center text-info\"&gt; &lt;h2&gt; 图书馆管理系统 &lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-lg-11\"&gt; &lt;input v-model=\"user.name\" type=\"text\" name=\"username\" placeholder=\"请输入账户名\" required autofocus/&gt; &lt;/div&gt; &lt;div class=\"col-lg-10\"&gt; &lt;/div&gt; &lt;div class=\"col-lg-10\"&gt; &lt;input v-model=\"user.passWord\" type=\"password\" name=\"password\" placeholder=\"请输入密码\" required/&gt; &lt;/div&gt; &lt;div class=\"col-lg-10\"&gt; &lt;/div&gt; &lt;div class=\"col-lg-10\"&gt; &lt;/div&gt; &lt;div class=\"col-lg-10\"&gt; &lt;button @click=\"login\" type=\"button\" id=\"btn\" class=\"btn btn-success col-lg-12\"&gt; 登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;/div&gt; 静态文件路径设置改写css，图片，以及前端框架js文件的路径到resource/webapp路径下，在idea中如下设置setting -&gt; project structure -&gt;facets设置web resource directory 这样外部静态文件能采用如下相对路径的方式引入： 1234567&lt;script src=\"js/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;link href=\"css/bootstrap/3.3.6/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;script src=\"js/bootstrap/3.3.6/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/vue/2.5.16/vue.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/axios/0.17.1/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/moment/2.22.2/moment.js\"&gt;&lt;/script&gt; &lt;!-- vue.js 格式化日期用的 --&gt;&lt;link href=\"css/back/style.css\" rel=\"stylesheet\"&gt;"},{"title":"web图书馆管理系统","permalink":"https://www.miaomiaomiao.info/遇到的问题/","text":"响应的json数据为一个json数组： [{id: 2, name: &quot;测试2&quot;, category: {id: 10, name: &quot;测试10&quot;}},…] 0: {id: 2, name: &quot;测试2&quot;, category: {id: 10, name: &quot;测试10&quot;}} 1: {id: 1, name: &quot;测试1&quot;, category: {id: 10, name: &quot;测试10&quot;}} 这时，在vue中取数据应该用response.data: listSearch:function () { var url = &quot;search?keyword=&quot;+vue.keyword; axios.post(url).then(function (response) { vue.beans = response.data; }) } Error creating bean with name ‘entityManagerFactory’ defined in class path resource提示这个错误往往是配置文件application.properties中数据库地址密码等配置有误 #database spring.datasource.url=jdbc:mysql://127.0.0.1:3306/library_manage?characterEncoding=UTF-8 spring.datasource.username=root spring.datasource.password=admin spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.hibernate.ddl-auto = none pojo实体类，service服务类，controller控制器类在springboot里都要加上相应的注解程序才能编译。这个初学容易忘加上，会编译出错。 pojo实体类加上@Entity，并标注对应的表名@Table,在主键id上也有对应的注解 @Entity @Table(name = &quot;user&quot;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;id&quot;) private int id; private String name; private String passWord; service类要注解@Service @Service public class BookService { @Autowired BookDAO bookDAO; @Autowired CategoryService categoryService; public void add(Book bean){ bookDAO.save(bean); } public void delete(int id){ bookDAO.delete(id); } public Book get(int id){ return bookDAO.findOne(id); } public void update(Book bean){ bookDAO.save(bean); } restful风格的controller要注解为@RestController @RestController public class BookController {.....} vue中，a标签href添加参数需在href前添加冒号，这样才能将bean.id值转化过来 &lt;a :href=&quot;&apos;admin_book_edit?id=&apos; + bean.id &quot;&gt; controller返回例如登录成功等一些消息，目前看最好是以对象的形式返回，返回的对象会自动转换为json对象 //Result类为专门返回登录成功后结果的类 public class Result { public static int SUCCESS_CODE = 1; public static int FAIL_CODE =0; public int code; public String message; private Result(int code,String message){ this.code = code; this.message = message; } public static Result success(){ return new Result(SUCCESS_CODE,null); } public static Result fail(){ return new Result(FAIL_CODE,&quot;密码错误&quot;); } } //LoginController代码片段，返回的是对象 @PostMapping(&quot;/login&quot;) public Object login(@RequestBody User userParam, HttpSession httpSession){ User user = userService.get(userParam.getName(),userParam.getPassWord()); if (user==null){ return Result.fail(); } else { httpSession.setAttribute(&quot;user&quot;,userParam); return Result.success(); } } //login.html中代码片段 login:function () { axios.post(vue.uri,this.user).then(function (response) { vue.result = response.data //respose.data即为{code:1,message:&quot;登录成功&quot;} if (vue.result.code ==1){ location.href=&quot;admin_category_list&quot; } else{ alert(vue.result.message) } }) } 块放错地方，注意vue的工作范围。el："},{"title":"web图书馆管理系统后端","permalink":"https://www.miaomiaomiao.info/springboot图书馆后/","text":"后端部分后端部分完全采用springboot的jpa方式进行数据库的操作，在接收请求方面采用的是restful风格。 后端工程目录，如图： 依次为 配置类（仅解决跨域） DAO类（数据库接口） 异常类（捕捉全局的异常） 实体类 服务类（封装操作数据库(DAO)的方法） 工具类（包含一个分页改进的分页功能和登录页面返回的结果信息类） 控制器类（实现页面跳转，和返回数据）分类管理 TIM截图20190326102748.png 分类表格的实现流程如下： listCategory.png 接下来依次叙述springboot一个实现分类目录列表的每一个类： 实体类Category：通过 1234567891011121314151617181920212223242526@Entity@Table(name = \"category\")@JsonIgnoreProperties(&#123; \"handler\",\"hibernateLazyInitializer\" &#125;)public class Category &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"id\") int id; String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 数据库接口类 123public interface CategoryDAO extends JpaRepository&lt;Category,Integer&gt;&#123;&#125; 服务类 1234567891011121314151617181920212223242526272829303132@Servicepublic class CategoryService &#123; @Autowired CategoryDAO categoryDAO; public Page4Navigator&lt;Book&gt; list(int start, int size, int navigatePages) &#123; Sort sort = new Sort(Sort.Direction.DESC, \"id\"); Pageable pageable = new PageRequest(start, size,sort); Page pageFromJPA =categoryDAO.findAll(pageable); //categoryDAO.findAll方法返回的结果就是一个page对象。当然是jpa中封装好的方法 return new Page4Navigator&lt;&gt;(pageFromJPA,navigatePages);// return pageFromJPA; &#125; public List&lt;Category&gt; list() &#123; Sort sort = new Sort(Sort.Direction.DESC, \"id\"); return categoryDAO.findAll(sort); &#125; public void add(Category bean)&#123; categoryDAO.save(bean); &#125; public void delete(int id)&#123; categoryDAO.delete(id); &#125; public Category get(int id)&#123; Category c = categoryDAO.findOne(id); return c; &#125; public void update(Category c)&#123; categoryDAO.save(c); &#125;&#125; controller类 123456789101112131415161718192021222324252627282930313233343536@RestControllerpublic class CategoryController &#123; @Autowired CategoryService categoryService; @GetMapping(\"/categories\") public Page4Navigator&lt;Book&gt; list(@RequestParam(value = \"start\", defaultValue = \"0\") int start, @RequestParam(value = \"size\", defaultValue = \"5\") int size) throws Exception &#123; start = start&lt;0?0:start; Page4Navigator&lt;Book&gt; page =categoryService.list(start, size, 5); //5表示导航分页最多有5个，像 [1,2,3,4,5] 这样 return page; &#125; @PostMapping(\"/categories\") public Object add(@RequestBody Category bean)&#123; categoryService.add(bean); return bean; &#125; @DeleteMapping(\"/categories/&#123;id&#125;\") public String delete(@PathVariable(\"id\") int id,HttpServletRequest request)&#123; categoryService.delete(id); File imageFile = new File(request.getServletContext().getRealPath(\"/img/category\")); File file = new File(imageFile,id+\".jpg\"); file.delete(); return null; &#125; @GetMapping(\"/categories/&#123;id&#125;\") public Category get(@PathVariable(\"id\") int id) throws Exception&#123; Category bean = categoryService.get(id); return bean; &#125; @PutMapping(\"/categories\") public Object update(@RequestBody Category bean)&#123; categoryService.update(bean); return bean; &#125;&#125; 分类名称修改流程： 点击修改图标，超链地址为(:href为vue超链写法，可以在链接中加vue对象属性): &lt;a :href=&quot;&apos;admin_book_list?cid=&apos; + bean.id &quot;&gt; admin_book_list在adminPagecontroller中跳转到editCategory.html页面 1234@GetMapping(value = \"/admin_category_edit\")public String editCategory()&#123; return \"admin/editCategory\";&#125; editCategory自动执行脚本中的get方法，获得超链问号之后的参数值bean.id即当前修改项的id值，并请求服务器返回当前id值的分类项的名称，放到编辑框中。 修改之后，点击提交按钮，执行update函数，提交请求和修改后的bean给服务器，服务器成功返回信息后，跳转页面至分类页面。 12345678910111213141516171819202122232425262728293031323334353637&lt;tr class=\"submitTR\"&gt; &lt;td colspan=\"2\" align=\"center\"&gt; &lt;input type=\"hidden\" name=\"id\" v-model.trim=\"bean.id\" &gt; &lt;a href=\"#nowhere\" class=\"btn btn-success\" @click=\"update\"&gt;提 交&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt;$(function () &#123; //$(function()&#123;...&#125;)jquery中表示文档一载入完毕就执行 var data4Vue=&#123; uri:'categories', listURL:'admin_category_list', bean:&#123;id:0,name:''&#125;, &#125;; var vue = new Vue(&#123; el:'#workingArea', data:data4Vue, mounted:function()&#123; this.get(); //mounted内自动执行 &#125;, methods:&#123; //methods注意s，不是method get:function ()&#123; //get方法请求服务器返回该分类对象 var id = getUrlParms(\"id\"); var url = this.uri+\"/\"+id; axios.get(url).then(function (response) &#123; vue.bean = response.data; &#125;) &#125;, update:function () &#123; var id = getUrlParms(\"id\"); var url = this.uri; axios.put(url,vue.bean).then(function (response) &#123; location.href = vue.listURL; &#125;); &#125; &#125; &#125;);&#125;); 新增分类项：新增分类比较简单，比修改简单，直接绑定的按钮执行add函数将请求的地址与bean一起传给服务器，服务器执行成功返回信息时更新列表。但因为整体用的是==restful风格==，因此axios请求插件在修改里用的是==put==方法，增加用的是==post==方法，对应于后端程序中的==PutMapping==和==PostMapping==，这样可以请求一致的url，但后台可以执行不同的方法 TIM截图20190327203922.png 删除分类项跟增加基本无异，但在vue中delete是关键字，在命名delete方法时改成deletebean，并且restful规范删除成功后服务器端要返回null，所以前端进行判断返回的数据是否为null,如果不为空，则打印处数据。1234567891011deleteBean:function (id) &#123; if(!checkDeleteLink()) return; var url = this.uri+\"/\"+id; axios.delete(url).then(function (response) &#123; if (0!=response.data.length) //rest规范删除数据要求要会返回空字符串（控制器类中delete返回null），所以进行判断 alert(response.data); else vue.list(0); //是空字符串则调第一页 &#125;)&#125; 分类下的书籍查询： 由于书籍和分类时多对一的关系，因此在书籍实体类中要用注解标明，如下在category属性上注解@ManyToOne和JoinColumn(name=”cid”)表示外键cid与category关联：1234567891011121314151617181920212223242526272829303132333435 @Entitypublic class Book &#123; @Id @Column(name = \"id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private String name; @ManyToOne @JoinColumn(name = \"cid\") private Category category; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 在DAO接口中写一个通过分类查询的方法，这方法命名规则是定死的，按照命名规则写，在==@AutoWired==生成的DAO对象中自动就有这个方法的具体实现。 1234public interface BookDAO extends JpaRepository&lt;Book,Integer&gt; &#123; Page&lt;Book&gt; findByCategory(Category category, Pageable pageable); //List&lt;Book&gt; findByNameLike(String keyword,Pageable pageable); //这个是后面用到的搜索&#125; 在service中，bookService.java中，除了增删改查的service方法还要加入一个通过分类名查询的方法。 1234567public Page4Navigator&lt;Book&gt; list(int cid,int start,int size,int navigatePages )&#123; Category category = categoryService.get(cid); //获取分类对象 Sort sort = new Sort(Sort.Direction.DESC,\"id\"); //设置排序方式的对象 Pageable pageable = new PageRequest(start,size,sort); //设置分页的对象 Page&lt;Book&gt; pageFromJPA = bookDAO.findByCategory(category,pageable); //DAO中通过分类查询到的结果 return new Page4Navigator&lt;&gt;(pageFromJPA,navigatePages);//返回查询的包含分页信息的书籍项&#125; 最后在bookController中接收页面发来的请求信息，来返回分类查询结果 1234567@GetMapping(\"/categories/&#123;cid&#125;/books\")public Page4Navigator&lt;Book&gt; list(@PathVariable(\"cid\") int cid, @RequestParam(value = \"start\",defaultValue = \"0\")int start, @RequestParam(value = \"size\",defaultValue = \"5\")int size)&#123; start = start&lt;0?0:start; Page4Navigator&lt;Book&gt; page = bookService.list(cid,start,size,5); return page;&#125; 搜索书籍功能搜索书籍功能放在前端的所有书籍页面里面。 在vue的data属性里定义号关键字keyword:””，并与搜索输入框绑定。 1&lt;input type=\"text\" class=\"form-control input-lg col-xs-4\" v-model=\"keyword\"&gt; 编写搜索请求函数listSearch，与按钮绑定： 12345678&lt;span @click=\"listSearch\" class=\"input-group-addon btn btn-primary\"&gt; listSearch:function () &#123; var url = \"search?keyword=\"+vue.keyword; axios.post(url).then(function (response) &#123; vue.beans = response.data; &#125;) &#125;, 在bookDAO中添加方法。名字定义方式findByNameLike,传入的参数为关键字，和分页信息 1234public interface BookDAO extends JpaRepository&lt;Book,Integer&gt; &#123; //Page&lt;Book&gt; findByCategory(Category category, Pageable pageable); List&lt;Book&gt; findByNameLike(String keyword,Pageable pageable);&#125; 在service中封装该方法 123456public List&lt;Book&gt; search(String name, int start, int size)&#123; Sort sort = new Sort(Sort.Direction.DESC,\"id\"); Pageable page = new PageRequest(start,size,sort); List&lt;Book&gt; books = bookDAO.findByNameLike(\"%\"+name+\"%\",page);//\"%\"+name+\"%\"表模糊查询 return books;&#125; 在searchController中接收关键字请求信息，返回搜索结果。 [ ] searchController可以与bookController合并 123456@AutowiredBookService bookService;@PostMapping(\"/search\")public Object search(@RequestParam(value = \"keyword\") String keyWord)&#123; return bookService.search(keyWord,0,20);&#125; 登录功能登录功能与前面的分类增加功能类似，前端将表单中的信息use.namer和user.password封装一个json数据user，发送给后端，后端通过注解@Requestbody自动将值赋给usr对象，userDAO将这个对象拿进数据库查询看是否在数据库中。判断后返回result对象，判断里面返回的信息是否是查询成功，成功则跳转到分类页面 ，查询结果为null的话则返回失败信息。 1234567891011121314151617 //userDAO添加通过用户名和密码查询的方式 public interface UserDAO extends JpaRepository&lt;User,Integer&gt; &#123; User getByNameAndPassWord(String name,String password); &#125;--- //登录页面的login函数请求服务器 login:function () &#123; axios.post(vue.uri,this.user).then(function (response) &#123; vue.result = response.data if (vue.result.code ==1)&#123; location.href=\"admin_category_list\" &#125; else&#123; alert(vue.result.message) &#125; &#125;) &#125; 12345678910111213141516//在searchController中将传过来的user的name和password进行查询@RestControllerpublic class LoginController &#123; @Autowired UserService userService; @PostMapping(\"/login\") public Object login(@RequestBody User userParam, HttpSession httpSession)&#123; User user = userService.get(userParam.getName(),userParam.getPassWord()); if (user==null)&#123; return Result.fail(); &#125; else &#123; httpSession.setAttribute(\"user\",userParam); return Result.success(); &#125; &#125;&#125;"},{"title":"Android与服务器端的通信实现登录注册","permalink":"https://www.miaomiaomiao.info/服务器端与android登录注册/","text":"Android与服务器端的通信实现登录注册配置服务器环境 首先服务器是搬瓦工的centos6 64位，配置java web环境即配置jdk，安装tomcat以及mysql按照这篇帖子搬瓦工java环境搭建 注意要删除自带的mysql的两个文件夹。 服务器端代码编写 主要写三个方面： 数据库 LoginServlet RegisterServlet 服务器mysql部分首先在服务器的mysql创建一个命名为zeng再创建一个表，命名为user，用来存储android端注册成功的用户信息记得进行授权：123//例如，你想root用户使用mypassword从任何主机连接到mysql服务器的话。GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '服务器mysql密码' WITH GRANT OPTION;FLUSH PRIVILEGES; 配置连接数据库的信息, 12345public static final String DB_USER = \"root\";//数据库用户名public static final String DB_PASSWORD = \"******\";//数据库密码public static final String DB_DATABASE = \"zeng\";//数据库名public static final String DB_URL = \"jdbc:mysql://104.243.30.196:3306/zeng\";//jdbc地址:服务器ip+数据库名public static final String DB_JDBC_MYSQL = \"com.mysql.jdbc.Driver\";//jdbc mysql 封装数据库jdbc连接方法，创建表以及增删改查的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class DBUtils &#123;private Connection connection = null;private Statement statement = null;public DBUtils() &#123;&#125;public DBUtils(String jdbc, String url, String user, String password) &#123; try &#123; Class.forName(jdbc); connection = DriverManager.getConnection(url, user, password); statement = connection.createStatement(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;/** * 创建表 * @param createSql */public void createTable(String createSql) &#123; try &#123; statement.execute(createSql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;/** * 插入数据 * @param table * @param columns * @param args * @return */public int insert(String table, String[] columns, String[] args) &#123; if(columns != null &amp;&amp; columns.length == 0) &#123; return -1; &#125; if(args != null &amp;&amp; columns.length != args.length) &#123; return -1; &#125; StringBuilder sql = new StringBuilder(); sql.append(\"INSERT INTO \"); sql.append(table + \"(\"); for(int i = 0; i &lt; columns.length - 1;i++) &#123; sql.append(columns[i]); sql.append(\",\"); &#125; sql.append(columns[columns.length - 1]); sql.append(\") VALUES(\"); for (int i = 0; i &lt; args.length - 1; i++) &#123; sql.append(\"?,\"); &#125; sql.append(\"?)\"); ResultSet rs = null; try &#123; PreparedStatement preparedStatement = connection.prepareStatement(sql.toString(),Statement.RETURN_GENERATED_KEYS); for (int i = 1; i &lt;= args.length; i++) &#123; preparedStatement.setString(i, args[i - 1]); &#125; preparedStatement.executeUpdate(); rs = preparedStatement.getGeneratedKeys(); if (rs.next()) &#123; return rs.getInt(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return -1;&#125; 创建数据库管理类DBMannager，包括创建表，对获取的用户email，密码写入数据库。其中要对数据进行json处理5."},{"title":"Android备忘录开发","permalink":"https://www.miaomiaomiao.info/android备忘录app开发/","text":"android备忘录开发 first day1.需求分析主要用于学生，特别是大学生和研究生经常忘记老师的作业，但他们又不习惯在纸上记录作业。但手机是他们每天必看的，因此设计一款app实现作业记录与提醒并对每科目开放一个聊天室供学习交流。 2.原型设计原型设计由mocplus设计 主界面 edit 3.表设计"},{"title":"高级组件","permalink":"https://www.miaomiaomiao.info/android第五天/","text":"进度条组件 布局文件12345678910&lt;ProgressBar android:id=\"@+id/progressBar1\" style=\"@android:style/Widget.ProgressBar.Horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"25dp\" android:layout_alignParentBottom=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"60dp\" android:max=\"100\" /&gt; //设置最大值 样式通过style属性进行设置： 样式 java代码 使用handler发送消息来控制进度条完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 private ProgressBar horizonP; //水平进度条 private int mProgressStatus = 0; //完成进度 private Handler mHandler; //声明一个用于处理消息的Handler类的对象 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); //设置全屏显示 horizonP = (ProgressBar) findViewById(R.id.progressBar1); //获取水平进度条 mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == 0x111) &#123; horizonP.setProgress(mProgressStatus); //更新进度 &#125; else &#123; Toast.makeText(MainActivity.this, \"耗时操作已经完成\", Toast.LENGTH_SHORT).show(); horizonP.setVisibility(View.GONE); //设置进度条不显示，并且不占用空间 &#125; &#125; &#125;; new Thread(new Runnable() &#123; public void run() &#123; while (true) &#123; mProgressStatus = doWork(); //获取耗时操作完成的百分比 Message m = new Message(); if (mProgressStatus &lt; 100) &#123; m.what = 0x111; mHandler.sendMessage(m); //发送信息 &#125; else &#123; m.what = 0x110; mHandler.sendMessage(m); //发送消息 break; &#125; &#125; &#125; //模拟一个耗时操作 private int doWork() &#123; mProgressStatus += Math.random() * 10; //改变完成进度 try &#123; Thread.sleep(200); //线程休眠200毫秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return mProgressStatus; //返回新的进度 &#125; &#125;).start(); //开启一个线程 &#125;&#125; 拖动条组件1234567&lt;SeekBar android:id=\"@+id/seekbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:max=\"255\" //最大值 android:progress=\"255\" //默认值 /&gt; java代码 实现通过拉动拖动条改变图片透明度：123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; private ImageView image; //定义图片 private SeekBar seekBar; //定义拖动条 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); image = (ImageView) findViewById(R.id.image); //获取图片 seekBar = (SeekBar) findViewById(R.id.seekbar); //获取拖动条 //为拖动条设置监听事件 seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; // 当拖动条的滑块位置发生改变时触发该方法 @Override public void onProgressChanged(SeekBar arg0, int progress, boolean fromUser) &#123; // 动态改变图片的透明度 image.setImageAlpha(progress); &#125; @Override public void onStartTrackingTouch(SeekBar bar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar bar) &#123; &#125; &#125;); &#125;&#125; 图像视图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.mingrisoft;import android.app.Activity;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.view.WindowManager;import android.view.animation.AnimationUtils;import android.widget.ImageSwitcher;import android.widget.ImageView;import android.widget.ViewSwitcher;public class MainActivity extends Activity &#123; private int[] arrayPictures = new int[]&#123;R.mipmap.img01, R.mipmap.img02, R.mipmap.img03, R.mipmap.img04, R.mipmap.img05, R.mipmap.img06, R.mipmap.img07, R.mipmap.img08, R.mipmap.img09, &#125;;// 声明并初始化一个保存要显示图像ID的数组 private ImageSwitcher imageSwitcher; // 声明一个图像切换器对象 //要显示的图片在图片数组中的Index private int pictutureIndex; //左右滑动时手指按下的X坐标 private float touchDownX; //左右滑动时手指松开的X坐标 private float touchUpX; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);//设置全屏显示 imageSwitcher = (ImageSwitcher) findViewById(R.id.imageswitcher); // 获取图像切换器 //为ImageSwicher设置Factory，用来为ImageSwicher制造ImageView imageSwitcher.setFactory(new ViewSwitcher.ViewFactory() &#123; @Override public View makeView() &#123; ImageView imageView = new ImageView(MainActivity.this); // 实例化一个ImageView类的对象 imageView.setImageResource(arrayPictures[pictutureIndex]);//根据id加载默认显示图片 return imageView; // 返回imageView对象 &#125; &#125;); imageSwitcher.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; //取得左右滑动时手指按下的X坐标 touchDownX = event.getX(); return true; &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123; //取得左右滑动时手指松开的X坐标 touchUpX = event.getX(); //从左往右，看下一张 if (touchUpX - touchDownX &gt; 100) &#123; //取得当前要看的图片的index pictutureIndex = pictutureIndex == 0 ? arrayPictures.length - 1 : pictutureIndex - 1; //设置图片切换的动画 imageSwitcher.setInAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.slide_in_left)); imageSwitcher.setOutAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.slide_out_right)); //设置当前要看的图片 imageSwitcher.setImageResource(arrayPictures[pictutureIndex]); //从右往左，看上一张 &#125; else if (touchDownX - touchUpX &gt; 100) &#123; //取得当前要看的图片index pictutureIndex = pictutureIndex == arrayPictures.length - 1 ? 0 : pictutureIndex + 1; //设置切换动画 imageSwitcher.setOutAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.slide_out_left)); imageSwitcher.setInAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.slide_in_right)); //设置要看的图片 imageSwitcher.setImageResource(arrayPictures[pictutureIndex]); &#125; return true; &#125; return false; &#125; &#125;); &#125;&#125; 图像切换器"},{"title":"普通组件","permalink":"https://www.miaomiaomiao.info/Android第四天/","text":"日期选择器日期选择器即在需要记录日期的时候弹出日期选择界面，如下图： 日期选择器 1234&lt;DatePicker android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/DatePicker&gt; 在java代码中获取所选日期123456789101112131415161718192021datepicker = (DatePicker)findViewById(R.id.xx)Calendar calendar = Calendar.getInstance();//下面的定义为给datePicker.init中初始化的值，当前的年月日year=calendar.get(Calendar.YEAR);mouth=calendar.get(Calendar.mouth);day=calendar.get(Calendar.DAY_OF_MOUTH);datePicker.init(year,mouth,day, new DatePicker.OnDatechangedListener()&#123; public void OnDatechanged(DatePicker view,int year,int mouthofyear,int day of mouth)&#123; MainActivity.this.year=year; //将监听事件中的年月日的值赋给这个activity中 MainActivity.this.month=mouthofyear; //的年月日 MainActivity.this.day=dayofmouth; &#125; &#125;);//定义一个show方法用toast来显示所选年月日private void show(int year,int mouth,int day)&#123; String str= year+\"年\"+mouth+1+\"月\"+day+\"日\"； Toast.makeText(MainActivity.this,strt,Toast.LENGTH_SHOW).show();&#125; 时间选择器如图： 时间选择器 123&lt;TimePicker xxxxx&gt;&lt;/TimePicker&gt;"},{"title":"坑总结","permalink":"https://www.miaomiaomiao.info/android中遇到的坑总结/","text":"在fragment中，findviewbyid及组件监听事件要写在onactivitycreated方法中，不然会报空指针异常。"},{"title":"Tomcat服务器在eclipse中的配置","permalink":"https://www.miaomiaomiao.info/j2ee第一天/","text":"Tomcat服务器在eclipse中的配置 new-&gt;other-&gt;Dynamic Web Project 选择Tomcat服务器 t 工程目录如下： t 在web-inf目录中创建web.xml，web-inf中的lib文件夹中存放需要用到的jar库，如servlet-api.jar等。"},{"title":"组件","permalink":"https://www.miaomiaomiao.info/Android第三天/","text":"一、编辑框1234567&lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_parent\" android:hint=\"请输入名字\" //输入框中的提示信息 android:drawableLeft=\"@mipmap/\" //将图像放在mipmap中 android:lines=\"5\" android:inputType=\"textPassword\"/&gt; //输入框中密码 属性drawableLeft实现在编辑框中的左侧放置图片如下图： EditText 二、buttom按钮组件 属性： 123android:layout_width=\"wrap_parent\"android:layout_height=\"wrap_parent\"android:text=\"按钮\" 事件监听器 123456Buttom b = (Buttom)findViewById(R.id.xx);b.setOnClickListener(new View.OnClickListener()&#123; public void onclick(View v)&#123; 写事件 &#125; &#125;) 三、ImageButtom图片按钮12android:src=\"@mipmap/xx\"android:background=\"#0000\" //设置背景透明，不然图片背景有灰色 四、RadioButton单选按钮和按钮组12android:text=\"xx\" //单选框后的文字android:checked=\"true\" //设置默认选中 将多个RadioButton用RadioButtonGroup组括起来才能实现单选的效果，即：123456789&lt;RadioButtonGroup android:id=\"@+id/xxx\" android:layout_width=\"wrap_parent\" android:layout_height=\"wrap_parent\"/&gt; &lt;RadioButton xxx/&gt; &lt;RadioButton xxx/&gt;&lt;/RadioButton&gt; Java代码：`RadioGroup rg = (RadioGroup)findViewById(R.id.xx)rg.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener(){ public void OnCheckedChange(RadioGroup group,int checkedID){ RadioButton r=(RadioButton)findViewById(checkedID); //通过参数checkedID取出所选单选框 r.getText(); //获取所选单选框的文本内容 } })"},{"title":"布局layout","permalink":"https://www.miaomiaomiao.info/Android第二天/","text":"Android布局一、relativeLayout 相对布局两个属性 android:gravity android:ingnoreGrivaty 组件属性123456android:layout_toLeftOf=\"@id/\"android:layout_toRightOf=\"@id/\"android:layout_belowandroid:layout_width=\"match_parent\" 匹配父控件宽度即relativeLayout。android:layout_alignParentRight=\"true\" 与父控件右端对齐android:layout_marginRight=\"50dp\" 并与右边相距50dp 二、LinearLayout 线性布局管理器两个属性12345android:orientation=\"vertical\"android:orientation=\"horizontal\"android:gravity=“center”android:gravity=“right” “right|bottom” //右下android:paddingBottom=\"20dp\"整个布局器占手机荧幕的边距。 前两个是指里面组件（如4个按钮）的排列方式为水平或垂直。gravity为里面组件整体所在的位置排列。如设为center则里面的按钮都在中间 三、FrameLayout 帧布局管理器两个属性12android:foreground //设置一个覆盖于前端的图片android:foregroundLayout 四、GridLayout 网格布局管理器两个属性123android:columnCount=“2” //指定网格最大列数，如5个按钮，设置为2，则2个换行android:orientation //不设置默认水平排列android:rowCount 组件内属性1234android:layout_columnandroid:layout_row 手动操作每个组件位于第几行几列android:layout_rowspanandroid:layout_gravity=\"fill\" 这两条表示跨行显示 五、布局管理器的嵌套 嵌套须知 嵌套例子"},{"title":"Android界面基础","permalink":"https://www.miaomiaomiao.info/Android第一天/","text":"Android界面UI控制Android界面控制 xml布局文件配置 java代码中控制 混合控制 自定义view xml布局文件配置： Android工程目录的res/layout中编写xml(activity_main)布局文件 然后在activity中使用java代码显示xml布局文件 1setContentView(R.layout.activity_main) oncreate方法是activity页面创建时执行的方法。 完全使用java代码控制界面 用的较少 混合控制 少 总结安卓界面主要分工给xml配置文件来写，实现java代码主要实现业务逻辑，xml主要用于界面。"},{"title":"P5天下第一!","permalink":"https://www.miaomiaomiao.info/P5天下第一/","text":"没什么好说的，p5天下第一"},{"title":"Hello World","permalink":"https://www.miaomiaomiao.info/hello-world/","text":""}]}